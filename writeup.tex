\documentclass[letterpaper, 10pt]{article}
\usepackage[headings]{fullpage}
\usepackage{amsmath, amsthm, amssymb, fancyhdr, mathptmx, enumerate}
\usepackage[pdftex]{graphicx}
\include{mathmacros}

\pagestyle{fancy}
\headheight 23pt
\lhead{Daniel Sommermann, Michael Gummelt}
\chead{CS240H, Hindsight Debugging}

\title{Hindsight Debugging \\
CS 240H: Functional Systems in Haskell}
\date{16 December 2011}
\author{
  \begin{tabular}{c c}
    Michael Gummelt & Daniel Sommermann \\
    \texttt{mgummelt@cs.stanford.edu} &
    \texttt{dcsommer@cs.stanford.edu}
  \end{tabular}
}
\newcommand{\ttt}{\texttt}

\begin{document}

\maketitle

\section{Abstract}
For this project we decided to explore the feasibility of a ``hindsight
debugger.'' Consider the following scenario: a programmer wants to debug a
piece of code, but isn't certain exactly where it goes
wrong. Traditionally, the programmer would have to set a breakpoint at
some arbitrary point and step through the code until some computation is
made that the programmer recognizes as invalid. If the programmer realizes
at a later point that the error was earlier, the debugging process must be
started once again, re-running the code, to hopefully catch the bug the
next time around.

In our debugger, we simplify this process by allowing inspection of the
stack on any line of code. In particular, our debugger allows the
programmer to inspect all stacks that existed while executing a particular
line of code. This way, a programmer can jump around to quickly pinpoint
the source of the error without being constrained by the semantics of 
debugging a live, running program.

To make our proof of concept debugger, we defined a simple language (MGDS)
that has functions, assignment, and integer arithmetic. We parse source
files using Parsec into an AST. Then, a specialized interpreter is run
over the AST, mapping line numbers to stacks. Finally, a debug loop is
entered wherein the user can query for stack and variable information for
any line of code. 

\section{Language Definition for MGDS}
The BNF of our language is given below
\begin{verbatim}
f = fn(x1, .., xn) { s; [s;] }

s = var = e
    return e
    returnif e, e

e = c1 | ... | cn (constants)
    (e)
    x
    e1 + e2
    e1 - e2
    e1 * e2
    e1 / e2
    e1 == e2
    !e1
    e1 && e2
    e1 || e2
    e1 == e2
    e1 < e2
    e1 > e2
    if e1 then e2 else e3
    f(e1, ..., en)
\end{verbatim}
MGDS is not a strictly pure language since it allows you to assign to the
same variable twice in one function. Arguments are passed by value during
function invocation, so the previous case is the only impure part of the
language. Also, there is no branching (besides early return via the
\ttt{returnif} operator) or looping in our language. The choice to omit
these constructs allowed us to quickly develop our debugger and
language. It also simplifies our model, since with loops, the same line of
code could be executed many, many times for a single function call. It is
a solvable problem (run the function body and the loop as many times as
the user specifies), but we leave this UI work for future research.

MGDS has strict semantics and evaluates expressions as soon as they are
encountered. Execution begins at the beginning of the \ttt{main()}
function. The value returned from \ttt{main()} is echoed once it is
computed. 

\section{Parsing}


\section{Interpretting and Storing}


\section{Debugging}T
There are a number of commands a user can use in our proof-of-concept debugger.

\section{Performance}
The implementation choices we made directly trade space for time. What
this means in particular is that in MGDS, since there is no IO or
non-determinism, that to get the state of the program at any point, the
debugger could just re-run the program to that exact point. However, for a
long running program, this could take a while. With our method, we instead
save state and only replay the evaluation within a single function.

<Graph of space vs time>

\section{Future Work}
There were numerous features that were cut in the interest of time. Arrays
were our next target and would have allowed us to implement sorting
algorithms. Support for other types besides ints was also planned.

File/IO/printing + complications

\section{Conclusions}
Blah...

Finally, if you are interested in seeing the details of our
implementation, our code is available to be viewed on Github at
\ttt{https://github.com/dcsommer/CS240H-Final-Project} .

\section{References}
\begin{enumerate}[{[}1{]}]

\item
\ttt{http://blogs.msdn.com/b/ianhu/archive}

\ttt{/2009/05/13/historical-debugging-in-visual-studio-team-system-2010.aspx}

\item


\item


\end{enumerate}
\end{document}
