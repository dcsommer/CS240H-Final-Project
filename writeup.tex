\documentclass[letterpaper, 10pt]{article}
\usepackage[headings]{fullpage}
\usepackage{amsmath, amsthm, amssymb, fancyhdr, mathptmx, enumerate}
\usepackage[pdftex]{graphicx}
\include{mathmacros}

\pagestyle{fancy}
\headheight 23pt
\lhead{Daniel Sommermann, Michael Gummelt}
\chead{CS240H, Hindsight Debugging}

\title{Hindsight Debugging \\
CS 240H: Functional Systems in Haskell}
\date{16 December 2011}
\author{
  \begin{tabular}{c c}
    Michael Gummelt & Daniel Sommermann \\
    \texttt{mgummelt@cs.stanford.edu} &
    \texttt{dcsommer@cs.stanford.edu}
  \end{tabular}
}
\newcommand{\ttt}{\texttt}

\begin{document}

\maketitle

\section{Abstract}
For this project we decided to explore the feasibility of a ``hindsight
debugger.'' Consider the following scenario: a programmer wants to debug a
piece of code, but isn't certain exactly where it goes
wrong. Traditionally, the programmer would have to set a breakpoint at
some arbitrary point and step through the code until some computation is
made that the programmer recognizes as invalid. If the programmer realizes
at a later point that the error was earlier, the debugging process must be
started once again, re-running the code, to hopefully catch the bug the
next time around.

In our debugger, we simplify this process by allowing inspection of the
stack on any line of code. In particular, our debugger allows the
programmer to inspect all stacks that existed while executing a particular
line of code. This way, a programmer can jump around to quickly pinpoint
the source of the error without being constrained by the semantics of 
debugging a live, running program.

To make our proof of concept debugger, we defined a simple language (MGDS)
that has functions, assignment, and integer arithmetic. We parse source
files using Parsec into an AST. Then, a specialized interpreter is run
over the AST, mapping line numbers to stacks. Finally, a debug loop is
entered wherein the user can query for stack and variable information for
any line of code. 

\section{Previous Work}
Microsoft's Visual Studio is the only other product we are aware of that
has similar functionality at the time of this writing, however, this
feature, called by Microsoft ``IntelliTrace,'' is only available in the
most expensive version of Visual Studio, which retails for thousands of
dollars per license.

Furthermore, IntelliTrace ...

\section{Language Definition for MGDS}
The BNF of our language is given below
\begin{verbatim}
f = fn(x1, .., xn) { s; [s;] }

s = var = e
    return e
    returnif e, e

e = c1 | ... | cn (constants)
    (e)
    x
    e1 + e2
    e1 - e2
    e1 * e2
    e1 / e2
    e1 == e2
    !e1
    e1 && e2
    e1 || e2
    e1 == e2
    e1 < e2
    e1 > e2
    if e1 then e2 else e3
    f(e1, ..., en)
\end{verbatim}
MGDS is not a strictly pure language since it allows you to assign to the
same variable twice in one function. Arguments are passed by value during
function invocation, so the previous case is the only impure part of the
language. Also, there is no branching (besides early return via the
\ttt{returnif} operator) or looping in our language. The choice to omit
these constructs allowed us to quickly develop our debugger and
language. It also simplifies our model, since with loops, the same line of
code could be executed many, many times for a single function call. It is
a solvable problem (run the function body and the loop as many times as
the user specifies), but we leave this UI work for future research.

MGDS has strict semantics and evaluates expressions as soon as they are
encountered. Execution begins at the beginning of the \ttt{main()}
function. The value returned from \ttt{main()} is echoed once it is
computed. 

\section{Parsing}
Parsing was made very easy using the applicative functors available in the
Attoparsec and Parsec libraries. Using this style, the code ends up
looking very close to the BNF used to describe the grammar in the
first place.

A first draft of the parser was first written based off the Attoparsec
library. This implementation worked incredibly well and was performant,
but unfortunately, Attoparsec does not support querying for cursor
position in the stream. This makes sense as Attoparsec was designed to be
a stripped down parser maximizing performance and not designed to generate
nice error messages.

On the other hand, Parsec is a more widely applicable parser that has
support for querying cursor position. Parsec's default implementation of
not ``backing out'' when an alternative fails differs from Attoparsecs,
forcusing us to wrap many alternatives in \ttt{try} functions when
refactoring the code.

Using Parsec, there were few times I felt that a first lexing pass was
necessary. Since parsing handles CFGs, it is of course well
known that lexing, which covers regular expressions, can be taken care of
in the parsing phase. Usually this is done simply for
convenience. However, because of how flexible Haskell and the Parsec
library is, it was relatively simple to wrap the parsing of comments and
whitespace inside the typcial, expected parsers with little to no code
bloat. This was a great result, and unexpected, since all my previous
experience with writing parsers have involved orders of magnitude more
code.

\section{Interpretting and Storing}


\section{Debugging}
There are a number of commands a user can use in our debugger.

\section{Performance}
The implementation choices we made directly trade space for time. What
this means in particular is that in MGDS, since there is no IO or
non-determinism, that to get the state of the program at any point, the
debugger could just re-run the program to that exact point. However, for a
long running program, this could take a while. With our method, we instead
save state and only replay the evaluation within a single function.

<Graph of space vs time>

\section{Future Work}
There were numerous features that were cut in the interest of time. Arrays
were our next target and would have allowed us to implement sorting
algorithms. Support for other types besides ints was also planned.

File/IO/printing + complications

\section{Conclusions}
Blah...

Finally, if you are interested in seeing the details of our
implementation, our code is available to be viewed on Github at
\ttt{https://github.com/dcsommer/CS240H-Final-Project} .

\section{References}
\begin{enumerate}[{[}1{]}]

\item
\ttt{http://blogs.msdn.com/b/ianhu/archive}

\ttt{/2009/05/13/historical-debugging-in-visual-studio-team-system-2010.aspx}

\item


\item


\end{enumerate}
\end{document}
